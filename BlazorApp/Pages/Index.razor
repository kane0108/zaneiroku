@page "/"
@inject IJSRuntime JS
@using Microsoft.AspNetCore.Components.Web
@using System.Text.Json
@using System.Drawing

<div id="fpsCounter"
     style="position:absolute; top:5px; left:5px; color:#0f0; font-family:monospace; font-size:14px; z-index:9999;">
</div>

<style>
    body {
        margin: 0;
        padding: 0;
        background-color: black;
        overflow: hidden;
        display: flex;
        justify-content: center;
        align-items: center;
        width: 100vw;
        height: 100vh;
    }

    #game-container {
        aspect-ratio: 9 / 16;
        height: 100vh;
        max-width: 100vw;
        background: transparent;
        position: relative;
        overflow: hidden;
    }

    canvas {
        width: 100%;
        height: 100%;
        display: block;
        background: black;
    }

    #inputArea {
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        z-index: 100;
        touch-action: none;
    }
</style>

<div id="game-container">
    <canvas id="gameCanvas"
            width="360" height="640"
            style="width: 360px; height: 640px; display: block; margin: auto;" />
</div>

<InputArea /> @* ←入力用パーツを重ねて配置 *@

@code {
    Game.GameMain _main = Game.GameMain.Instance;
    private float _lastTime = 0;

    private bool _readyToDraw = false;
    private bool _gaugeInitDone = false;

    // PreloadAssetsAsync
    private Dictionary<string, Game.Sprite.ImageSize> _preloadedSizes;

    private async Task PreloadAssetsAsync()
    {
        Game.SaveManager.JS = JS;
        Game.SaveCrypto.Initialize(JS);

        // ★ もうこれだけでOK
        var allImages = Game.Common.GetAllImages();

        _preloadedSizes = await JS.InvokeAsync<Dictionary<string, Game.Sprite.ImageSize>>(
        "preloadImagesWithSize", (object)allImages);

        // ★ static に保存
        Game.Sprite.PreloadedSizes = _preloadedSizes;

        Console.WriteLine($"✅ Preload 完了 (sizes={_preloadedSizes.Count})");
    }

    /// <summary>
    /// 描画初期化完了後処理
    /// </summary>
    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (firstRender && !_gaugeInitDone)
        {
            // ATBゲージ幅の初期化
            var gm = Game.GameMain.Instance;
            float targetPx = gm.GaugeTargetPx;
            string font = gm.GaugeFont;
            float pad = gm.GaugePaddingPx;

            float charPx = await JS.InvokeAsync<float>("measureTextWidth", "█", font);
            int maxChars = Math.Max(1, (int)MathF.Round((targetPx - pad) / MathF.Max(1e-3f, charPx)));
            gm.SetAtbMaxChars(maxChars);

            _gaugeInitDone = true;
            StateHasChanged();
        }

        if (firstRender)
        {
            // ★ 1. プリロードを先に実行
            await PreloadAssetsAsync();   // ← 自作のプリロード関数

            // 2. 入力キャンセル処理を設定
            await JS.InvokeVoidAsync("preventTouchDefaults", "gameCanvas");

            // 3. キャンバスサイズ調整
            await JS.InvokeVoidAsync("adjustCanvasSize", "gameCanvas");

            // 4. シーン初期化（ここで CurrentScene が作られる）
            _main.Initialize();

            // 5. 描画を許可
            _readyToDraw = true;

            // 6. 初期負荷回避（1フレームスキップ）
            await Task.Delay(16);

            // 7. ゲームループ開始
            await StartGameLoop();
        }
    }

    /// <summary>
    /// ゲームループ
    /// </summary>
    private async Task StartGameLoop()
    {
        var sw = System.Diagnostics.Stopwatch.StartNew();

        while (true)
        {
            float now = sw.ElapsedMilliseconds / 1000f;
            float delta = now - _lastTime;
            _lastTime = now;
            delta = MathF.Min(delta, 0.1f);

            _main.Update(delta);

            if (_main.CurrentScene != null && _readyToDraw)
            {
                await JS.InvokeVoidAsync("clearCanvas", "gameCanvas");
                await DrawFrameAsync();
            }

            await JS.InvokeVoidAsync("updateFpsCounter");

            await Task.Delay(16); // ≒ 60fps
        }
    }

    /// <summary>
    /// フレーム描画処理（drawBatch 専用）
    /// </summary>
    private async Task DrawFrameAsync()
    {
        var scene = _main.CurrentScene;
        if (scene == null) return;

        var commands = new List<object>();

        // 背景（遠景〜中景）
        scene.Background?.CollectDrawCommands(commands, JS, foregroundOnly: false, fadeOpacity: _main.FadeOpacity);

        // キャラ
        foreach (var ch in scene.Characters.Values.ToList())
            ch.CollectDrawCommands(commands, JS, _main.FadeOpacity);

        // 前景（雨粒など）
        scene.Background?.CollectDrawCommands(commands, JS, foregroundOnly: true, fadeOpacity: _main.FadeOpacity);

        // UI（子UI含む）
        foreach (var ui in scene.UIObjects.Values.ToList().OrderBy(u => u.ZIndex))
            ui.CollectDrawCommands(commands, JS, _main.FadeOpacity);

        foreach (var ui in scene.CommonUIObjects.Values.ToList().OrderBy(u => u.ZIndex))
            ui.CollectDrawCommands(commands, JS, _main.FadeOpacity);

        // フェード矩形（黒幕）
        if ((_main.FadeState == Game.FadeState.FadingOut || _main.FadeState == Game.FadeState.FadingIn)
            && _main.FadeOpacity > 0f)
        {
            commands.Add(new
            {
                type = "fadeRect",
                canvasId = "gameCanvas",
                opacity = _main.FadeOpacity
            });
        }

        // 通常の描画コマンドを全部追加したあとにデバッグメッセージも追加
        if (Game.GameMain.Instance.DebugMessages.Count > 0)
        {
            float y = 20;
            foreach (var msg in Game.GameMain.Instance.DebugMessages.TakeLast(5))
            {
                commands.Add(new
                {
                    type = "text",
                    canvasId = "gameCanvas",
                    text = msg,
                    x = 10,
                    y,
                    textColor = "red",
                    font = "14px monospace",
                    align = "left"
                });
                y += 18;
            }
        }

        // === JS に一括送信 ===
        if (commands.Count > 0)
        {
            // zIndex を取り出してソート
            var ordered = commands.OrderBy(cmd =>
            {
                if (cmd is IDictionary<string, object> dict && dict.ContainsKey("zIndex"))
                {
                    return Convert.ToInt32(dict["zIndex"]);
                }
                else if (cmd is JsonElement elem && elem.TryGetProperty("zIndex", out var z))
                {
                    return z.GetInt32();
                }
                return 0;
            }).ToList();

            var results = await JS.InvokeAsync<object[]>("drawBatch", ordered);

            // StretchToText のサイズ反映
            int idx = 0;
            foreach (var ui in scene.UIObjects.Values.ToList().OrderBy(u => u.ZIndex))
            {
                if (ui.StretchToText)
                {
                    if (idx < results.Length &&
                        results[idx] is JsonElement elem &&
                        elem.TryGetProperty("width", out var w) &&
                        elem.TryGetProperty("height", out var h))
                    {
                        float width = w.GetSingle();
                        float height = h.GetSingle();
                        ui.DrawnWidth = width;
                        ui.DrawnHeight = height;
                        ui.UpdateHitRect(ui.HitRect.X, ui.HitRect.Y, width, height);
                    }
                    idx++;
                }
            }
        }
    }

    private void ApplyPreloadedSizes(Game.Scene scene)
    {
        if (_preloadedSizes == null) return;

        foreach (var kv in _preloadedSizes)
        {
            var sprite = FindSpriteByPathInScene(scene, kv.Key);
            if (sprite != null && (sprite.SourceRect.Width == 0 || sprite.SourceRect.Height == 0))
            {
                sprite.SourceRect = new Rectangle(0, 0, kv.Value.Width, kv.Value.Height);
                Console.WriteLine($"[InitSize] {sprite.ImagePath} -> {kv.Value.Width}x{kv.Value.Height}");
            }
        }
    }

    private Game.Sprite? FindSpriteByPathInScene(Game.Scene scene, string path)
    {
        // 背景
        if (scene.Background != null)
        {
            foreach (var layer in scene.Background.Layers)
            {
                if (layer.Sprite?.ImagePath == path)
                    return layer.Sprite;
            }
        }

        // キャラ
        foreach (var ch in scene.Characters.Values)
        {
            var sp = ch.GetCurrentFrameSprite();
            if (sp != null && sp.ImagePath == path)
                return sp;
        }

        // UI
        foreach (var ui in scene.UIObjects.Values.Concat(scene.CommonUIObjects.Values))
        {
            var sp = ui.GetCurrentFrameSprite();
            if (sp != null && sp.ImagePath == path)
                return sp;
        }

        return null;
    }
}
